/* ------------------------------------------------------------------------- */
/* mdsPutCh.c - device-aware mdsPut interface                                */
/* ------------------------------------------------------------------------- */
/*   Copyright (C) 2005 Peter Milne, D-TACQ Solutions Ltd
 *                      <Peter dot Milne at D hyphen TACQ dot com>
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of Version 2 of the GNU General Public License
 as published by the Free Software Foundation;
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, LSA.                */
/* ------------------------------------------------------------------------- */

/** @file mdsPutCh.cpp device-aware mdsPut interface
 * 
 * this is a custom client for mdsshell-af_unix server.
 *

- mdsPutCh --expr EXPR --field FIELDFMT --timebase TIMEBASE channels

 - CHANNELS: list | range
  - selects channels to read from memory
  - list : 1,2,3,6,9,12
  - range: 1-16 (or 1:16 or :)
  - channels outside channel mask are ignored.

 - TIMEBASE: start,samples,stride
  - selects range of samples to read from memory
  - start: 	default 0
  - samples: 	default *  (all samples subject to <start>, <stride>).
  - stride: 	default 1
  - alternative notation:   :,:,1
  - TWO keywords are defined to help with pre, post upload:
   - %PRE : substitutes PRE samples in data set.
   - %POST : substitutes POST samples in data set.

 - FIELDFMT : sprintf format string to build channel name.
  -For each channel, code calls sprintf( buf, FIELDFMT, channel)
  -default: %2d

 - EXPR:  
  - default : $  - mdsPlus data identity.

  - KEYWORDS : format specifiers, analogous to printf format fields. KEYWORDS begin with \% 
   - KEYWORD SUBSTITUTIONS - most keywords are simple short hand
    - \%CAL : this builds a raw to volts expression using the calibrated range, taking into account the current range setting for the channel, applying straight line formula:
     - \%CAL : (\%V1 + (\%V2 - \%V1)*($ -\%R1)/(\%R2 - \%R1))
    - \%R1, \%R2 : range range limits, default \%R1 = -32768,  \%R2 = +32767
  - KEYWORDS ...
   - KEYWORD EVALUATIONS - certain built-in keywords have custom, per-channel values inserted on processing a channel:
    - \%V1, \%V2 : current calibrated voltage range limits from get.vin
    - \%S0 : Start sample index from trigger
    - \%S1 : Index at trigger (always zero)
    - \%S2 : End sample index from trigger
    - \%DT : Time between samples, assuming a known clock. Includes stride
    - \%DECIM : Decimation factor (ACQ132)

It is possible to create a custom user expression based on these values, for example:

  - --expr "(%V1 + $MYOFFSET + (%V2 - %V1)*($ -%R1)/(%R2 - %R1))"

  - DYNAMIC KEYWORDS : additional keywords may be defined at run time by adding lines to either of two setup files
   - $HOME/.mdsPutCh.sh   - keywords generated by shell processing
    - default .mdsPutCh.sh:
	<pre>
        # .mdsPutCh.sh - variables with shell interpretation
	# HostName is used for canonical card name convention
	echo %HN=`hostname`
	</pre>
   - $HOME/.mdsPutCh.nosh - literal keyword definitions
    - default .mdsPutCh.nosh
	<pre>
	# .mdsPutCh.nosh - variables with NO SHELL interpretation.
	# this is a comment. NB we need spaces around ':' because it is a valid tok char
	# generic digitizer timebase support - %T2 is end time
	%T0=(%S0*%DT)
	%T2=(%S2*%DT)
	# timebase ... the Window takes the subrange into account 
	%win=Build_Window(0, %S2-%S0, Build_With_Units(0.0, 'seconds'))
	%axis=Build_With_Units(Build_Range(%T0, %T2, %DT), 'seconds')
	%tbase=Build_Dim(%win, %axis)
	# Build a raw to volts scaling expression
	%SCAL=Build_With_Units((%V1 + (%V2 - %V1)*($VALUE - %R1)/(%R2 - %R1)),'volts')
	# top level expression is quoted to beat shell quoting on command line
	%calsig="Build_Signal(%SCAL,$,%tbase)"
	</pre>

  - Saving data to MDSPLUS SIGNALS with correct timebase
   - use the %calsig expression
   - works with full, and sub timebases - the --timebase switch is automatically translated into the MDSplus expression.

@todo: future options to supporting REPEATED GATE:

 - --subshots <n,[step]>  : number of times to step and repeat timebase
 - --subfield SUBFMT      : MDSplus field definition %d substitutes step#
                          : subfield prepends field when set
 - --dataroot-format FMT  : format statement for source data
			    default: /dev/acq200/data/%02d

Examples
# upload 96 channels, all the data, raw expression

- mdsPutCh --field "HYPERACQ:CH%02d" 1:96

# upload 96 channels with unique calibration expression per channel

- mdsPutCh --field "HYPERACQ:CH%02d" --expr %CAL 1:96

# upload 96 channels with signal timebase and calibration:

- mdsPutCh --field "HYPERACQ:CH%02d" --expr %calsig 1:96

# upload 96 channels with a stride of 100 (for rapid upload) :

- mdsPutCh --field "HYPERACQ:SUB_CH%02d" --expr %calsig --timebase 1,:,100 1:96

# upload 10000 samples starting at sample #50000 :

- mdsPutCh --field "HYPERACQ:ROI_CH%02d" --expr %calsig --timebase 50000,10000,1 1:96

# upload 10 subshots, length 10000

mdsPutCh  -- subshots 10 --timebase 1,10000,1 --subfield "SUBSHOT%04d" --field "CH%02d" 1:96
*/

#define BUILD "$Id: mdsPutCh.cpp,v 1.35 2010/06/15 16:52:31 pgm Exp $ $Revision: 1.35 $ B1015"

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include <fcntl.h>
#include <sys/select.h>
#include <sys/socket.h>
#include <sys/syslog.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/un.h>
#include <unistd.h>
#include <signal.h>
#include <sys/stat.h>
#include <sys/wait.h>

#include <assert.h>
#include <errno.h>

#define PROCLOGNAME "mdsPutCh"


#define CUSTOM_EXP_NOSH  ".mdsPutCh.nosh"
#define CUSTOM_EXP_SH    ".mdsPutCh.sh"


#define KW_V1  "%V1"
#define KW_V2  "%V2"
#define KW_R1  "%R1"
#define KW_R2  "%R2"
#define KW_CAL "%CAL"

#define KW_S0	"%S0"		/** Start sample index from trigger.	*/
#define KW_S1	"%S1"		/** Index at trigger (zero).		*/
#define KW_S2	"%S2"		/** End sample index from trigger.	*/
#define KW_DT	"%DT"		/** Delta time between samples [s].
				    Includes stride			*/
#define KW_DECIM "%DECIM"	/** Decimation factor (ACQ132).		*/

#define KW_STRIDE "%STR"	/** Stride */

#define DEFTIMEBASE ":,:,1"

extern "C" {
int acq200_debug = 0;
}
#include "local.h"
#include "acq-util.h"

//#include "usc.h"
#include "mdsshell.h"
#include <popt.h>



#include <list>

#include "parser.h"

#include "InputBlockWrapper.h"


#include "Timebase.h"

#define DEBUG_SOCK   "/tmp/mdsshell.debug"
#define _COMMAND_SOCK "/tmp/mdsshell.command"

const char* COMMAND_SOCK = _COMMAND_SOCK;

extern "C" int readline( int fd, char *bufptr, size_t len );

class UnixSocket {
	struct sockaddr_un address;
	int sock;
public:
	UnixSocket(int _sock) : sock(_sock) 
	{
	}

	UnixSocket(const char* _path) {
		if ((sock = socket(PF_UNIX, SOCK_STREAM, 0)) < 0){
			perror("socket");
			exit(-errno);
		}
		address.sun_family = AF_UNIX;
		strcpy(address.sun_path, _path);
		
		int addrLen = 
			sizeof(address.sun_family) + 
			strlen(address.sun_path);

		if (connect(sock, (struct sockaddr *)&address, addrLen)){
			perror( "connect failed SOCK" );
			exit(-errno);
		}
	}
	~UnixSocket() {		
	}
	int operator() () { return sock; }
};


class CBuf {
/* closure buffer */
public:
	char *buf;

	CBuf(int len) {
		buf = new char[len];
		buf[0] = '\0';
	}
	~CBuf() { delete [] buf; }
};





class MdsShellTransaction {
	UnixSocket& us;
public:
	int errors;

	MdsShellTransaction(UnixSocket& _us) : 
		us(_us), errors(0) {}
public:
	int put(const char* command) {
		return write(us(), command, strlen(command));
	}
	char *get(char *buf, int maxbuf) {
		CBuf mybuf(maxbuf);
		char *pbuf = buf;

		do {
			int rc = readline(us(), pbuf, maxbuf);
			if (rc < 0){
				err("readLine err %d", rc);
				exit(-errno);
			}
/** BUG what if field is called ERROR ? should be on EOF line ? */
			if (strstr(pbuf, "ERROR") || strstr(pbuf, "FAIL")){
				++errors;
				err("MDS ERROR: %s", pbuf);
			}
			pbuf = mybuf.buf;
		} while (!strstr(pbuf, "EOF"));

		return buf;
	}
};

#ifdef __zynq
#define DEFSITE	0
#else
#define DEFSITE -1
#endif
int site = DEFSITE;  		/* global share with InputBlock */

static struct Globs {
	const char *expr;
	const char *field;
	const char *timebase;
	const char* subshots;
	const char* subfield;	
	const char* dataroot_format;
	UnixSocket* mds;
	ChannelSelection *channels;
	int sendfile;
}
	GL = {
		/* .expr =  */ "$",
		/* .field = */ "%02d",
		/* .timebase = */ DEFTIMEBASE,
		/* .subshots = */ "",
		/* .subfield = */ "",
		/* .dataroot_format = */ "/dev/acq400/data/%d/%02d",
		0
	};


int norestore;

#define REPEAT_FOREVER -1
int repeatn = REPEAT_FOREVER;

/** parse expression and evaluate for given Timebase. default works for '$' */




class Expression;

typedef list<string>::iterator       VSI;
typedef list<string>::const_iterator VSCI;
typedef list<Expression*>::const_iterator VECI;

class Expression {

protected:
	const string key;
	Parser<list<string> > parser;
public:
	Expression(const Expression& exp) :
		key(exp.key.c_str()), parser(exp.parser) {
		// we're assuming that subs have already been made. ?.
		printf("YOOOHOOO CLONE ALERT\n" );
	}
	Expression(
		const char* _key,
		const char* _expr, 
		int nosubs = 0) : 
			key(_key), parser(_expr) {
	}	
	virtual ~Expression() {}
	virtual int evaluate(char* buf, int maxbuf, Range range) 
								   const = 0;

	friend class RootExpression;

	virtual void print() const {
		printf("%-10s => \"", key.c_str());
		
		VSCI end = parser.const_list().end(); 
		for (VSCI i = parser.const_list().begin(); i != end; ++i){
			fputs(i->c_str(), stdout);
		}

		printf("\"\n");
	}
};
class RootExpression : public Expression {
	static list<Expression*> expressions;
	static list<Expression*> substitutions;     /* list of Expressions, simple expansion required */
	static list<Expression*> evaluations;        /* list of Expressions, per channel evaluation required */

	static int verbose;

	void substitute(VSI ito, const Expression* src_exp) {
		const list<string> src_list = src_exp->parser.const_list();

		for (VSCI ifrom = src_list.begin();
		     ifrom != src_list.end(); ++ifrom){

			dbg(3, "insert %s", ifrom->c_str());

			parser.list().insert(ito, *ifrom);
		}

		parser.list().erase(ito);
	}
	static void createSubstitutions();
	static void createEvaluations();

	int evaluate_key(
		const char* key, char* buf, int maxbuf, Range& range) const {

		dbg(2, "key : %s", key);

		for (VECI eval = evaluations.begin(); 
		     eval != evaluations.end(); ++eval){

			dbg(3, "compare %s %s", key, (*eval)->key.c_str());

			if ((*eval)->key.compare(key) == 0){

				dbg(2, "compare %s %s call evaluate()", 
				    key, (*eval)->key.c_str());

				return (*eval)->evaluate(buf, maxbuf, range);
			}
		}
		return 0;
	}

public:
	static Timebase* timebase;



	static void create() {
		static int in_create;

		if (getenv("RootExpressionVerbose")){
			verbose = atoi(getenv("RootExpressionVerbose"));
		}
		if (in_create){
			return;
		}else{
			in_create = 1;
		}

		createSubstitutions();
		createEvaluations();	
		// splice clears source list
		list<Expression*> s2(substitutions);
		expressions.splice(expressions.begin(), s2);
		list<Expression*> e2(evaluations);
		expressions.splice(expressions.end(), e2);
		in_create = 0;
	
	}
	static void listAll() {
		for (VECI exp = expressions.begin(); 
		     exp != expressions.end(); ++exp){
			(*exp)->print();
		}
	}

	static int is_key(const string& key){
		return key.c_str()[0] == '%';
	}
	static int is_key(const char* key) {
		return key[0] == '%';
	}
public:
	virtual int evaluate(char* buf, int maxbuf, Range range) const {
		char *pbuf = buf;
		int rem = maxbuf;

		VSCI end = parser.const_list().end();
		for (VSCI i = parser.const_list().begin(); 
			i != end && rem > 0; ++i){
			dbg(3, "item: %s", i->c_str());

			if (is_key(*i)){
				int rc = evaluate_key(
					i->c_str(), pbuf, rem, range);
				if (rc > 0){
					dbg(2, "evaluate OK : %s", pbuf);
					rem -= rc;
					pbuf += rc;
					continue;
				}
			}
			
			strncpy(pbuf, i->c_str(), rem);
			pbuf += strlen(pbuf);
			rem -= strlen(pbuf);
		}


		dbg(2, "outputs buf \"%s\"", buf);

		if (verbose) fprintf(stderr, "%s \"%s\"\n", _PFN, buf);

		assert(pbuf-buf < maxbuf);

		return pbuf - buf;
	}

	RootExpression(
		const char* _key,
		const char* _expr, 
		int nosubs = 0) : 
			Expression(_key, _expr, nosubs) {

		int ix = 0;

		if (substitutions.size() == 0){
			create();
		}

		if (nosubs) return;

		dbg(1, "top level expression %s", _expr);

	loop:
		VSI end = parser.list().end();
		for (VSI i = parser.list().begin(); i != end; ++i, ++ix){

			dbg(2, "%2d: \"%s\" %s", ix, i->c_str(),
			    is_key(*i)? "ISKEY": "not key");

			if (!is_key(*i)){
				continue;
			}

			dbg(3, "we have a key \"%s\" possible subs %d",
			    i->c_str(), substitutions.size());


			/*
			 *  compare with the evaluations first. 
			 *  these guys don't substitute, and they are few
			 */
			int nosub = 0;
			VECI endev = evaluations.end();
			for (VECI ev = evaluations.begin(); ev != endev; ++ev){
				if (i->compare((*ev)->key.c_str()) == 0){
					nosub = 1;
					break;
				}
			}
			if (nosub){
				dbg(3, "nosub");
				continue;
			}

			// now check key for substitutions
			       
			VECI endse =  substitutions.end(); 
			for (VECI se = substitutions.begin();se != endse;++se){

				dbg(3, "substitutions %s", (*se)->key.c_str());

				if (i->compare((*se)->key.c_str()) == 0){

					dbg(2,"substitute %s",(*se)->key.c_str());

					substitute(i, *se);
					goto loop;
				}
			}
		}
	}
};

#define NOSUBS 1

list<Expression*> RootExpression::substitutions;
list<Expression*> RootExpression::evaluations;
list<Expression*> RootExpression::expressions;

int RootExpression::verbose;
Timebase* RootExpression::timebase;

class ExpressionLoader {

private:
	static int exists(const char* fname) {
		struct stat buf;
		return stat(fname, &buf) == 0;
	}
	FILE* fp;
	
	int is_key(const char* line) {
		return line[0] == '%';
	}
	int is_comment(const char* line){
		return line[0] == '#';
	}
	int is_blank(const char* line){
		return line[0] == '\n' || line[0] == '\0';
	}
		
	void chomp(char *line) {
		char *ep = line + strlen(line);

		while(*--ep){
			switch(*ep){
			case '\n':
			case '\r':
				*ep = '\0';
				continue;
			default:
				return;
			}
		}
	}
public:		
	void load(list<Expression*>& expressions) {
/* load expressions from file, NO shell subst */
		char line[256];
		int iline = 0;

		while(fgets(line, sizeof(line), fp)){
			chomp(line);
			dbg(2, "[%2d] \"%s\"", ++iline, line);

			if (is_key(line)){
				char *equals = index(line, '=');
				if (equals == 0){
					err("NOT key=value \"%s\"", line);
					continue;
				}else{
					*equals = '\0';
					char* key = line;
					char* value = equals + 1;
					expressions.push_front(
						new RootExpression(
							key, value, NOSUBS));
				}
			}else if (is_comment(line) || is_blank(line)){
				continue;
			}else{
				err("continuation not supported at this time");
			}
		}
	}


	static ExpressionLoader* getNosh() {
		char fname[80];
		snprintf(fname, 80, "%s/%s", getenv("HOME"), CUSTOM_EXP_NOSH);
		
		if (exists(fname)){
			FILE* fp = fopen(fname, "r");

			assert(fp);
			return new ExpressionLoader(fp);
		}else{
			return 0;
		}
	}
	static ExpressionLoader* getSh() {
		char fname[80];
		snprintf(fname, 80, "%s/%s", getenv("HOME"), CUSTOM_EXP_SH);

		if (exists(fname)){
			char command[256];
			snprintf(command, 256, ". %s", fname);
			FILE* fp = popen(command, "r");

			assert(fp);
			return new ExpressionLoader(fp);
		}else{
			return 0;
		}		
	}
private:
	ExpressionLoader(FILE* _fp) : fp(_fp) {
		;
	}
};

class Evaluator {
protected:
	int _evaluate(char* buf, int maxbuf, int x) const {
		return snprintf(buf, maxbuf, "%d", x);
	}
public:
	virtual int evaluate(char* buf, int maxbuf) const = 0;
	virtual ~Evaluator() {}
};

class EvalS0: public Evaluator {
public:	
	virtual int evaluate(char* buf, int maxbuf) const {
		return _evaluate(buf, maxbuf, RootExpression::timebase->getS0());
	}
};

class EvalS1: public Evaluator {
public:	
	virtual int evaluate(char* buf, int maxbuf) const {
		return _evaluate(buf, maxbuf, 0);
	}
};

class EvalS2: public Evaluator {
public:
	virtual int evaluate(char* buf, int maxbuf) const {
		return _evaluate(buf, maxbuf, 
					RootExpression::timebase->getS2());
	}
};

class EvalDT: public Evaluator {
public:
	virtual int evaluate(char* buf, int maxbuf) const {
		return snprintf(buf, maxbuf, "%s", 
				RootExpression::timebase->getDt());
	}
};

class EvalStride: public Evaluator {
public:
	virtual int evaluate(char* buf, int maxbuf) const {
		return _evaluate(buf, maxbuf,
				 RootExpression::timebase->getStride());
	}	
};
class ProxyExpression : public Expression {
	const Evaluator* e;
public:
	ProxyExpression(const char* kw, Evaluator* _e) :
		Expression(kw, "", NOSUBS),
		e(_e)
	{

	}
	
	virtual int evaluate(char* buf, int maxbuf, Range range) const {
		assert(e != 0);
		return e->evaluate(buf, maxbuf);		
	}
};


#define CALEX "\"(%V1 + (%V2 - %V1)*($ - %R1)/(%R2 - %R1))\""

void RootExpression::createSubstitutions() {
	substitutions.push_front(new RootExpression(KW_CAL, CALEX, NOSUBS));

	ExpressionLoader* nosher = ExpressionLoader::getNosh();

	if (nosher != 0){
		nosher->load(substitutions);
	}

	ExpressionLoader* shload = ExpressionLoader::getSh();
	if (shload != 0){
		shload->load(substitutions);
	}
}


class VMaxExpression : public Expression {
public:
	virtual int evaluate(char* buf, int maxbuf, Range range) const {
		dbg(1, "VMaxExpression::evaluate(%s)", buf);
		float vmin = range.isReversed()? range.rmin: range.rmax;
		return sprintf(buf, "%f", vmin);
	}
	VMaxExpression(const Expression& exp) :
		Expression(exp)
	{}

	VMaxExpression(const char* _key) :
		Expression( _key, "VMax", 1)
	{}
};


class VMinExpression : public Expression {
public:
	virtual int evaluate(char* buf, int maxbuf, Range range) const {
		float vmax = range.isReversed()? range.rmax: range.rmin;
		return sprintf(buf, "%f", vmax);
	}
	VMinExpression(const Expression& exp) :
		Expression(exp)
	{}

	VMinExpression(const char* _key) :
		Expression( _key, "VMin", 1)
	{}
};

class CodeMaxExpression : public Expression {
public:
	virtual int evaluate(char* buf, int maxbuf, Range range) const {
		return strlen(strncpy(buf, range.code_max, maxbuf));
	}
	CodeMaxExpression(const Expression& exp) :
		Expression(exp)
	{}

	CodeMaxExpression(const char* _key) :
		Expression( _key, "CMax", 1)
	{}	
};

class CodeMinExpression : public Expression {
public:
	virtual int evaluate(char* buf, int maxbuf, Range range) const {
		return strlen(strncpy(buf, range.code_min, maxbuf));
	}
	CodeMinExpression(const Expression& exp) :
		Expression(exp)
	{}

	CodeMinExpression(const char* _key) :
		Expression( _key, "CMin", 1)
	{}	
};


class DecimExpression : public Expression {
public:
	virtual int evaluate(char* buf, int maxbuf, Range range) const {
		return RootExpression::timebase->getDecimation(range);
	}
	DecimExpression(const Expression& exp) :
		Expression(exp)
	{}

	DecimExpression(const char* _key) :
		Expression( _key, "DECIM", 1)
	{}	
};
void RootExpression::createEvaluations() {
	evaluations.push_front(new CodeMaxExpression(KW_R2));
	evaluations.push_front(new CodeMinExpression(KW_R1));
	evaluations.push_front(new VMaxExpression(KW_V2));
	evaluations.push_front(new VMinExpression(KW_V1));

	evaluations.push_front(new ProxyExpression(KW_S0, new EvalS0()));
	evaluations.push_front(new ProxyExpression(KW_S1, new EvalS1()));
	evaluations.push_front(new ProxyExpression(KW_S2, new EvalS2()));
	evaluations.push_front(new ProxyExpression(KW_DT, new EvalDT()));
	evaluations.push_front(new DecimExpression(KW_DECIM));
	evaluations.push_front(
		new ProxyExpression(KW_STRIDE,new EvalStride()));
}


static void mdsPutChannel(int ch, const char* src_file, const char* expr, Timebase& timebase, char* cmd_buf, int max_buf){
	dbg(1, "ch %02d expr \"%s\" timebase \"%s\" =>", ch, expr, 
	     timebase.toString());

	MdsShellTransaction command(*GL.mds);


	char tbuf[128];
	char *cmdp = cmd_buf;

	cmdp += sprintf(cmdp, "mdsPut --format short --expr %s ", expr);
	cmdp += sprintf(cmdp, "--timebase %s ", GL.timebase);
	cmdp += sprintf(cmdp, "--dim %d %s %s ", timebase.getSamples(), "--file", src_file);

	sprintf(tbuf, GL.field, ch);
	strcat(cmdp, tbuf);

	assert(cmdp-cmd_buf < MAXEXP);

	dbg(1, "send: \"%s\"", cmd_buf);

	command.put(cmd_buf);
	if (command.get(tbuf, sizeof(tbuf)) == 0){
		err("COMMAND failed");
		exit(-errno);
	}

	dbg(1, "done: \"%s\"", chomp(tbuf));

	if (command.errors){
		err("COMMAND ERROR");
		exit(-1);
	}
}


#define GCM	"acqcmd getChannelMask"
#define ACQPFX	"ACQ32:getChannelMask="

class ChannelMask {
	char* the_mask;
	char* buf;
	int len;
public:
	ChannelMask(void){
		buf = new char[256];
		buf[0] = '\0';

		FILE *fp = popen(GCM, "r");
		if (fgets(buf, 256, fp)){
			if (strstr(buf, ACQPFX)){
				the_mask = buf+strlen(ACQPFX);
				chomp(the_mask);
				len = strlen(the_mask);

				dbg(1, "ChannelMask() SUCCESS len:%d the_mask:\"%s\"", len, the_mask);
			}
		}
	}
	virtual ~ChannelMask() {
		delete [] buf;
	}
	int contains(int ch) {
		int ich = ch - 1;

		dbg(1, "ch:%d ich:%d the_mask:\"%s\"", ch, ich, the_mask);
		if (ich >= 0 && ich < len){
			return the_mask[ich] != '0';
		}
		return 0;
	}
};


unsigned guard0 = 0xdeadbeef;
static char channel_exp[MAXEXP];
unsigned guard1 = 0xdeadbeef;

#define MAXCMD	(MAXEXP+1024)
char cmd_buf[MAXCMD];
unsigned guard2 = 0xdeadbeef;



static int mdsPutCh(InputBlockWrapper& inputBlock) {
	RootExpression expression("%top", GL.expr);
	ChannelSelectionIterator it(*GL.channels);
	Timebase* timebase = Timebase::create(GL.timebase, !norestore);
	ChannelMask channel_mask;


	dbg(1, "channels %s expression %s", 
	    GL.channels->toString(), GL.expr);

	RootExpression::timebase = timebase;

	for (int ch; (ch = it.getNext()) > 0; ){

		if (!channel_mask.contains(ch)){
			dbg(1, "ERROR: channel %d not in mask", ch);
			continue;
		}
		
		dbg(2, "evaluate channel %d rmin %f rmax %d", 
		    ch, 
		    inputBlock.getRange(ch).rmin,
		    inputBlock.getRange(ch).rmax );
		expression.evaluate(
			channel_exp, MAXEXP, inputBlock.getRange(ch));

		char src_file[128];
		sprintf(src_file, GL.dataroot_format,
				inputBlock.getSite(ch), inputBlock.pchan(ch));
		dbg(2, "evaluate done, call mdsPutChannel(%d, %s, %s)",
		    ch, src_file, channel_exp);

		mdsPutChannel(ch, src_file, channel_exp, *timebase, cmd_buf, MAXCMD);

		dbg(2, "mdsPutChannel() returned guard0:%x guard1:%x guard2:%x", guard0, guard1, guard2);
	}

	dbg(1, "now delete timebase");

	delete timebase;

	assert(guard1 == 0xdeadbeef);
	dbg(1, "99");
	return 0;
}

static void handleUsr2(int signum){
	// do nothing

}
static int doRepeatMode(InputBlockWrapper& inputBlock) {
        static struct sigaction sa = { { 0 } };
	sa.sa_handler = handleUsr2;

        if (sigaction(SIGUSR2, &sa, NULL)){
                perror("sigaction");
        }
	FILE* fp = fopen(".mdsPutCh.pid", "w");
	assert(fp);
	fprintf(fp, "%d\n", getpid());
	fclose(fp);

	while( (repeatn == REPEAT_FOREVER || repeatn-- > 0) && pause()){
		mdsPutCh(inputBlock);
	}
	return 0;
}

static struct poptOption opt_table[] = {
{ "site", 0, POPT_ARG_INT, &::site, 0 },
{ "expr",  'E', POPT_ARG_STRING, &GL.expr, 0,
       "default : $" },
{ "field", 'F', POPT_ARG_STRING, &GL.field, 0,
	"mdsplus field name %02d substitutes channel" },
{ "dataroot-format", 'D', POPT_ARG_STRING, &GL.dataroot_format, 0,
	"source data format, eg /dev/acq400/data/%d/%02d %d: site, %02d substitutes channel" },
{ "timebase", 'T', POPT_ARG_STRING, &GL.timebase, 0,
        "start,length,stride, default: all [" DEFTIMEBASE "]" },
{ "subshots", 'S', POPT_ARG_INT, &GL.subshots, 'S',
	"number of times to step and repeat timebase [0]"},
{ "subfield", 's', POPT_ARG_STRING, &GL.subfield, 's',
	"mdsfield name prepends \"field\", %04d substitutes subshot [blank]"},
{ "verbose", 'v', POPT_ARG_INT, &acq200_debug, 0 },
{ "norestore", 0, POPT_ARG_INT, &norestore, 0 },
{ "version",   0, POPT_ARG_NONE, 0, 'v' },
{ "repeat",  'r', POPT_ARG_NONE, 0, 'r', 
      "block on SIGUSR2, then loop. PID stored in $PWD/.mdsPutCh.pid" },
{ "repeatn",  'R', POPT_ARG_INT, &repeatn, 'r', 
     "block on SIGUSR2, then loop N times. PID stored in $PWD/.mdsPutCh.pid" },
{ "list",  0,     POPT_ARG_NONE, 0, 'l',
      "list available keywords" },
POPT_AUTOHELP
POPT_TABLEEND		
};

static void initContext()
{
	/** sendfile mode default if no switch, else MUST be specified */
	const char* sendfile = getenv("SENDFILE");

	if (sendfile){
		GL.sendfile = 0;
		int mode;
		if (sscanf(sendfile, "SENDFILE=%d", &mode) == 1){
			if (mode == 1){
				GL.sendfile = 1;
			}
		}
	}else{
		GL.sendfile = 0;
	}

	dbg(2, "sendfile %d", GL.sendfile);

	const char *command_sock = getenv("COMMAND_SOCK");
	if (command_sock){
		COMMAND_SOCK = command_sock;
	}
	dbg(2, "COMMAND_SOCK %s", COMMAND_SOCK);
}


int repeat_mode = 0;


int get_args(int argc, const char* argv[], const char **&params)
{
	int rc;	
	poptContext opt_context = 
		poptGetContext(argv[0], argc, argv, opt_table, 0);
	while ((rc = poptGetNextOpt(opt_context)) > 0){
		switch(rc){
		case 'S':
		case 's':
			err("Sorry, option no available yet");
			break;
		case 'v':
			fprintf(stderr, "mdsPutCh " BUILD "\n");
			exit(1);
		case 'r':
			repeat_mode = 1;
			break;
		case 'l':
			RootExpression::create();
			RootExpression::listAll();
			exit(0);
		default:
			;
		}
	}
	int argc2;
	const char ** argv2 = poptGetArgs(opt_context);

	for (argc2 = 0; argv2 && argv2[argc2] != 0; ++argc2){

	}
	if (argc2){
		params = argv2;
	}
	return argc2;	
}  

int process(int nparams, const char** params, InputBlockWrapper& inputBlock)
{
	dbg(1, "make ChannelSelection %d", nparams);

	GL.channels = new ChannelSelection(
		inputBlock.getNumChannels(), nparams, params);

	if (repeat_mode){
		return doRepeatMode(inputBlock);
	}else{
		return mdsPutCh(inputBlock);
	}	
} 

#define MAXLINE 4096

int main(int argc, const char* argv[])
{
	initContext();

	const char** params;
	int nparams = get_args(argc, argv, params);

	InputBlockWrapper& inputBlock = InputBlockWrapper::create(site);

	dbg(1, "InputBlockWrapper with %d channels", inputBlock.getNumChannels());

	/* parent may set COMMAND_SOCK=N where N is an open file descriptor */
	if (atoi(COMMAND_SOCK) > 0){
		GL.mds = new UnixSocket(atoi(COMMAND_SOCK));
	}else{
		GL.mds =  new UnixSocket(COMMAND_SOCK);
	}
	
	if (nparams == 0){
		/** command[s] on stdin - saves inputBlock overhead */
		char* buf = new char[MAXLINE];
		int rc = 0;
		
		while (fgets(buf, MAXLINE, stdin)){
			char* l_argv[20];			
			int l_argc = strsplit(buf, l_argv, 20, " ");
			int l_params =  get_args(
					l_argc, (const char**)l_argv, params);
			
			if (l_params){
				rc = process(l_params, params, inputBlock);				
				if (rc != 0){
					break;		
				}
			}
		}
				
		delete [] buf;
		return rc;
	}else{
		return process(nparams, params, inputBlock);	
	}
}
